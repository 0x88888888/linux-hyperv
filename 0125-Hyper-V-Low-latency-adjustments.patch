From 51944a3d95791d70cfdfc1ead0f222cf5ab4e230 Mon Sep 17 00:00:00 2001
From: "K. Y. Srinivasan" <kys@microsoft.com>
Date: Wed, 8 Jun 2016 17:43:45 -0700
Subject: [PATCH 125/132] Hyper-V: Low latency adjustments

Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
---
 drivers/hv/channel.c              |  3 ++-
 drivers/hv/connection.c           |  8 ++++----
 drivers/net/hyperv/netvsc.c       | 18 ++++++++++++++++++
 drivers/net/hyperv/rndis_filter.c |  2 ++
 drivers/scsi/storvsc_drv.c        |  6 ++++++
 include/linux/hyperv.h            |  1 +
 6 files changed, 33 insertions(+), 5 deletions(-)

diff --git a/drivers/hv/channel.c b/drivers/hv/channel.c
index 56dd261..ab2c941 100644
--- a/drivers/hv/channel.c
+++ b/drivers/hv/channel.c
@@ -43,7 +43,8 @@ static void vmbus_setevent(struct vmbus_channel *channel)
 {
 	struct hv_monitor_page *monitorpage;
 
-	if (channel->offermsg.monitor_allocated) {
+	if ((channel->offermsg.monitor_allocated) &&
+	    (channel->low_latency == false)) {
 		/* Each u32 represents 32 channels */
 		sync_set_bit(channel->offermsg.child_relid & 31,
 			(unsigned long *) vmbus_connection.send_int_page +
diff --git a/drivers/hv/connection.c b/drivers/hv/connection.c
index fcf8a02..352c40a 100644
--- a/drivers/hv/connection.c
+++ b/drivers/hv/connection.c
@@ -439,7 +439,7 @@ int vmbus_post_msg(void *buffer, size_t buflen)
 	union hv_connection_id conn_id;
 	int ret = 0;
 	int retries = 0;
-	u32 msec = 1;
+	u32 usec = 5;
 
 	conn_id.asu32 = 0;
 	conn_id.u.id = VMBUS_MESSAGE_CONNECTION_ID;
@@ -472,9 +472,9 @@ int vmbus_post_msg(void *buffer, size_t buflen)
 		}
 
 		retries++;
-		msleep(msec);
-		if (msec < 2048)
-			msec *= 2;
+		udelay(usec);
+		if (usec < 2048)
+			usec *= 2;
 	}
 	return ret;
 }
diff --git a/drivers/net/hyperv/netvsc.c b/drivers/net/hyperv/netvsc.c
index 410fb8e8..49c29bb 100644
--- a/drivers/net/hyperv/netvsc.c
+++ b/drivers/net/hyperv/netvsc.c
@@ -53,10 +53,12 @@ void netvsc_switch_datapath(struct net_device *ndev, bool vf)
 		init_pkt->msg.v4_msg.active_dp.active_datapath =
 			NVSP_DATAPATH_SYNTHETIC;
 
+	dev->channel->low_latency = true;
 	vmbus_sendpacket(dev->channel, init_pkt,
 			       sizeof(struct nvsp_message),
 			       (unsigned long)init_pkt,
 			       VM_PKT_DATA_INBAND, 0);
+	dev->channel->low_latency = false;
 }
 
 
@@ -138,11 +140,13 @@ static int netvsc_destroy_buf(struct hv_device *device)
 		revoke_packet->msg.v1_msg.
 		revoke_recv_buf.id = NETVSC_RECEIVE_BUFFER_ID;
 
+		device->channel->low_latency = true;
 		ret = vmbus_sendpacket(device->channel,
 				       revoke_packet,
 				       sizeof(struct nvsp_message),
 				       (unsigned long)revoke_packet,
 				       VM_PKT_DATA_INBAND, 0);
+		device->channel->low_latency = false;
 		/*
 		 * If we failed here, we might as well return and
 		 * have a leak rather than continue and a bugchk
@@ -198,11 +202,13 @@ static int netvsc_destroy_buf(struct hv_device *device)
 		revoke_packet->msg.v1_msg.revoke_send_buf.id =
 			NETVSC_SEND_BUFFER_ID;
 
+		device->channel->low_latency = true;
 		ret = vmbus_sendpacket(device->channel,
 				       revoke_packet,
 				       sizeof(struct nvsp_message),
 				       (unsigned long)revoke_packet,
 				       VM_PKT_DATA_INBAND, 0);
+		device->channel->low_latency = false;
 		/* If we failed here, we might as well return and
 		 * have a leak rather than continue and a bugchk
 		 */
@@ -289,11 +295,13 @@ static int netvsc_init_buf(struct hv_device *device)
 		send_recv_buf.id = NETVSC_RECEIVE_BUFFER_ID;
 
 	/* Send the gpadl notification request */
+	device->channel->low_latency = true;
 	ret = vmbus_sendpacket(device->channel, init_packet,
 			       sizeof(struct nvsp_message),
 			       (unsigned long)init_packet,
 			       VM_PKT_DATA_INBAND,
 			       VMBUS_DATA_PACKET_FLAG_COMPLETION_REQUESTED);
+	device->channel->low_latency = false;
 	if (ret != 0) {
 		netdev_err(ndev,
 			"unable to send receive buffer's gpadl to netvsp\n");
@@ -372,11 +380,13 @@ static int netvsc_init_buf(struct hv_device *device)
 	init_packet->msg.v1_msg.send_send_buf.id = NETVSC_SEND_BUFFER_ID;
 
 	/* Send the gpadl notification request */
+	device->channel->low_latency = true;
 	ret = vmbus_sendpacket(device->channel, init_packet,
 			       sizeof(struct nvsp_message),
 			       (unsigned long)init_packet,
 			       VM_PKT_DATA_INBAND,
 			       VMBUS_DATA_PACKET_FLAG_COMPLETION_REQUESTED);
+	device->channel->low_latency = false;
 	if (ret != 0) {
 		netdev_err(ndev,
 			   "unable to send send buffer's gpadl to netvsp\n");
@@ -444,11 +454,13 @@ static int negotiate_nvsp_ver(struct hv_device *device,
 	init_packet->msg.init_msg.init.max_protocol_ver = nvsp_ver;
 
 	/* Send the init request */
+	device->channel->low_latency = true;
 	ret = vmbus_sendpacket(device->channel, init_packet,
 			       sizeof(struct nvsp_message),
 			       (unsigned long)init_packet,
 			       VM_PKT_DATA_INBAND,
 			       VMBUS_DATA_PACKET_FLAG_COMPLETION_REQUESTED);
+	device->channel->low_latency = false;
 
 	if (ret != 0)
 		return ret;
@@ -471,10 +483,12 @@ static int negotiate_nvsp_ver(struct hv_device *device,
 	if (nvsp_ver >= NVSP_PROTOCOL_VERSION_5)
 		init_packet->msg.v2_msg.send_ndis_config.capability.sriov = 1;
 
+	device->channel->low_latency = true;
 	ret = vmbus_sendpacket(device->channel, init_packet,
 				sizeof(struct nvsp_message),
 				(unsigned long)init_packet,
 				VM_PKT_DATA_INBAND, 0);
+	device->channel->low_latency = false;
 
 	return ret;
 }
@@ -527,10 +541,12 @@ static int netvsc_connect_vsp(struct hv_device *device)
 				ndis_version & 0xFFFF;
 
 	/* Send the init request */
+	device->channel->low_latency = true;
 	ret = vmbus_sendpacket(device->channel, init_packet,
 				sizeof(struct nvsp_message),
 				(unsigned long)init_packet,
 				VM_PKT_DATA_INBAND, 0);
+	device->channel->low_latency = false;
 	if (ret != 0)
 		goto cleanup;
 
@@ -985,9 +1001,11 @@ static void netvsc_send_recv_completion(struct hv_device *device,
 
 retry_send_cmplt:
 	/* Send the completion */
+	device->channel->low_latency = true;
 	ret = vmbus_sendpacket(channel, &recvcompMessage,
 			       sizeof(struct nvsp_message), transaction_id,
 			       VM_PKT_COMP, 0);
+	device->channel->low_latency = false;
 	if (ret == 0) {
 		/* success */
 		/* no-op */
diff --git a/drivers/net/hyperv/rndis_filter.c b/drivers/net/hyperv/rndis_filter.c
index 8e830f7..d16ed25 100644
--- a/drivers/net/hyperv/rndis_filter.c
+++ b/drivers/net/hyperv/rndis_filter.c
@@ -1091,11 +1091,13 @@ int rndis_filter_device_add(struct hv_device *dev,
 	init_packet->msg.v5_msg.subchn_req.op = NVSP_SUBCHANNEL_ALLOCATE;
 	init_packet->msg.v5_msg.subchn_req.num_subchannels =
 						net_device->num_chn - 1;
+	dev->channel->low_latency = true;
 	ret = vmbus_sendpacket(dev->channel, init_packet,
 			       sizeof(struct nvsp_message),
 			       (unsigned long)init_packet,
 			       VM_PKT_DATA_INBAND,
 			       VMBUS_DATA_PACKET_FLAG_COMPLETION_REQUESTED);
+	dev->channel->low_latency = false;
 	if (ret)
 		goto out;
 	wait_for_completion(&net_device->channel_init_wait);
diff --git a/drivers/scsi/storvsc_drv.c b/drivers/scsi/storvsc_drv.c
index 13142ab..98f06a9 100644
--- a/drivers/scsi/storvsc_drv.c
+++ b/drivers/scsi/storvsc_drv.c
@@ -678,12 +678,14 @@ static void  handle_multichannel_storage(struct hv_device *device, int max_chns)
 	vstor_packet->flags = REQUEST_COMPLETION_FLAG;
 	vstor_packet->sub_channel_count = num_sc;
 
+	device->channel->low_latency = true;
 	ret = vmbus_sendpacket(device->channel, vstor_packet,
 			       (sizeof(struct vstor_packet) -
 			       vmscsi_size_delta),
 			       (unsigned long)request,
 			       VM_PKT_DATA_INBAND,
 			       VMBUS_DATA_PACKET_FLAG_COMPLETION_REQUESTED);
+	device->channel->low_latency = false;
 
 	if (ret != 0)
 		return;
@@ -736,12 +738,14 @@ static int storvsc_execute_vstor_op(struct hv_device *device,
 	init_completion(&request->wait_event);
 	vstor_packet->flags = REQUEST_COMPLETION_FLAG;
 
+	device->channel->low_latency = true;
 	ret = vmbus_sendpacket(device->channel, vstor_packet,
 			       (sizeof(struct vstor_packet) -
 			       vmscsi_size_delta),
 			       (unsigned long)request,
 			       VM_PKT_DATA_INBAND,
 			       VMBUS_DATA_PACKET_FLAG_COMPLETION_REQUESTED);
+	device->channel->low_latency = false;
 	if (ret != 0)
 		return ret;
 
@@ -1353,12 +1357,14 @@ static int storvsc_host_reset_handler(struct scsi_cmnd *scmnd)
 	vstor_packet->flags = REQUEST_COMPLETION_FLAG;
 	vstor_packet->vm_srb.path_id = stor_device->path_id;
 
+	device->channel->low_latency = true;
 	ret = vmbus_sendpacket(device->channel, vstor_packet,
 			       (sizeof(struct vstor_packet) -
 				vmscsi_size_delta),
 			       (unsigned long)&stor_device->reset_request,
 			       VM_PKT_DATA_INBAND,
 			       VMBUS_DATA_PACKET_FLAG_COMPLETION_REQUESTED);
+	device->channel->low_latency = false;
 	if (ret != 0)
 		return FAILED;
 
diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index b10954a..a7336c1 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -851,6 +851,7 @@ struct vmbus_channel {
 	 */
 	bool acquire_ring_lock;
 
+	bool low_latency;
 };
 
 static inline void set_channel_lock_state(struct vmbus_channel *c, bool state)
-- 
2.10.2

